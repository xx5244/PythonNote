# Pandas
---

+ ## 結構化數據分析利器(依賴Numpy)
+ ## 提供多種高級數據結構
    1. Time-Series
    2. DataFrame
    3. Panel
+ ## 強大數據索引和處理能力

+ ## Series
  + ### 說明
    **Pandas套件底下的方法，一維維度的表格，以list為基底**
  + ### 範例
    ```python
    import numpy as np
    import pandas as pd

    a = [1, 2, 3, 4]

    # 創建一個空白的Series
    # s = pd.Series([], dtype=pd.StringDtype()) # 宣告空白的Series要給定資料型態，不然會出現警告

    # 創建一個Series
    # s = pd.Series(a)
    # print(s)  # 印出內容
    # print(s.index)    # 印出索引
    # print(s.values)   # 印出值
    # print("索引1的值:", s[1]) # 索引方式印出值
    # print("最大值:", s.max())
    # print("最小值:", s.min())
    # print("中位數:", s.median())
    # print("資料放大兩倍:", s * 2, sep="\n")

    # 篩選資料
    # condition = s > 2
    # print("內容值大於2的內容:", s[condition], sep="\n")


    # 自定義index
    # s1 = Series(a, index=['A', 'B', 'C', 'D'])
    # print(s1)

    # 透過numpy的array創建Series
    # s2 = Series(np.arange(5))
    # print(s2)

    # 透過字典創建Series
    # d = {
    #     'A': 1,
    #     'B': 2,
    #     'C': 3,
    #     'D': 4
    # }
    # s3 = pd.Series(d)
    # print(s3)
    # print(s3.index)
    # print(s3.values)

    # 將Series轉換成字典
    # d2 = s3.to_dict()
    # print(d2)


    """
    注意: 創建空白的Series時，最好先給定資料型態，不然之後可能會有警告出現
    index會默認自動創建，也可以指定
    用字典創建的Series，字典中的key會變成index，而value就會變成value
    將Series轉成字典的話，就是index轉乘key，value轉成value
    """
    ```

+ ## DataFrame
  + ### 說明
    **Pandas套件底下的方法，二維維度的表格，以dict為基底**
  
  + ### 常用功能
    1. **製作資料**
       + #### 範例
          ```python
          import pandas as pd

          a = [1, 2, 3, 4]

          # 創建一個DataFrame
          ind = ['a', 'b', 'c']
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)
          data2 = pd.DataFrame(data_dict, index=ind)  # 指定index

          print(data)
          print(f'{"="*30}')
          print(data2)
          ```
    2. **儲存資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建一個DataFrame
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)
          data.to_csv('test.csv', encoding='utf-8', index=None)   # 輸出成csv檔
          """
          to_csv: 輸出成csv檔，當然也可以輸出成別的檔案類型，編碼建議用utf-8，index預設是有的，如果不要就要設定為None
          """       
          ```
    3. **讀取資料**
       + #### 範例
          ```python
          import pandas as pd

          data = pd.read_csv('test.csv', header=None) # 讀取csv檔
          print(data)
          """
          read_csv: 讀取csv檔變成DataFrame形式，header為是否把第一列當作是屬性，預設為是，如不要就要設定為None
          """          
          ```
    4. **查詢與篩選資料**
       + #### 範例
          ```python
          import pandas as pd       

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)  # 不指定index
          # data = pd.DataFrame(data_dict, index=a) # 指定index
          # 查看row
          # print(data.head()) # 顯示前5 row
          # print(data.tail()) # 顯示後5 row

          # 查看column
          # print(data.columns) # 查看columns

          # 取row的內容
          # print(data[0:3])  # 直觀好用
          # print(data.loc[['a', 'b']])   # 指定index，文字類就不能用區間了，要將預讀取的row都一一列出
          # print(data.loc[0:2])  # 不指定index也可用區間
          # print(data.iloc[0:2])  

          # 讀取column內容
          # print(data['name'])
          # print(data.name)  # 不建議使用此方法
          # print(data.iloc[:, 0])

          # 讀取多column內容
          # print(pd.DataFrame(data, columns=['name', 'heigh']))

          # 讀取row及column綜合運用
          # print(data.loc[0:2, ['name', 'salary']])
          # print(data.iloc[0:3, 0:2])

          # 查詢資料
          # print(data.isin([5000, 'Amy'])) # 找出DataFrame裡是否有值為5000或者'Amy'的
          # print(data['name'].isin(['Amy']))   # 找出name欄位裡有沒有叫'Amy'的

          # 篩選資料
          # condition = data['salary'] > 4000
          # print(data[condition])

          # 篩選資料搭配判別式
          # condition1 = data['salary'] > 3500 # 薪水大於3500
          # condition2 = data['heigh'] > 200    # 身高大於200
          # if condition1.bool and condition2.bool: # 如果兩個條件都符合
          #     print(data[condition1][condition2]) # 把結果印出來          
          
          # 比對兩個DataFrame中重複的資料
          # data1 = {
          #     'name': ['林心如', '黃慈敏', '糖兒'],
          #     'heigh': [160, 158, 178]
          # }

          # data2 = {
          #     'name': ['寶貝', '心茹', '黃慈敏', 'Linda'],
          #     'cup': ['C', 'E', 'C', 'A']
          # }

          # data1 = pd.DataFrame(data1)
          # data2 = pd.DataFrame(data2)

          # print(pd.merge(data1, data2, left_on='name', right_on='name', how='inner'))

          # 比對兩個DataFrame中相異的資料
          # result = pd.merge(data1, data2, left_on='name', right_on='name', how='outer', indicator=True)
          # print(result.loc[lambda x : x['_merge'] != 'both'])
          
          # 建議不要用chained indexing
            import pandas as pd

            data = {
                "auctionid": ["8213034705", "8213034705", "8213034705", "8213034705", "8213060420"],
                "bidder": ["jake7870", "davidbresler2", "gladimacowgirl", "daysrus", "donnie4814"],
                "bidderrate": [0, 1, 58, 10, 5],
                "price": [110.8, 424, 553, 10, 553],
            }
            data = pd.DataFrame(data)

            # case 1
            # data[data["bidder"] == "davidbresler2"]["bidderrate"] = 100
            # print(data)

            # case 1 解法
            # data.loc[data["bidder"] == "davidbresler2", "bidderrate"] = 100
            # print(data)


            # case 2
            # temp = data.loc[data["bidderrate"] == data["price"]]
            # temp.loc[3, "bidder"] = "therealname"
            # print(temp)

            # case 2 解法
            # temp = data.loc[data["bidderrate"] == data["price"]].copy()
            # temp.loc[3, "bidder"] = "therealname"
            # print(temp)


            # 利用正則表達式來篩選資料
            # 將欄位中的BH後面的值給取出來，並放到新增名為new的欄位裡
            import pandas as pd
            import re

            data = pd.DataFrame(
                {"OBJ_DESC": ["BH163.9cm(75-90)", "BH: 16cm(>97) 0.9cm/2m 110.3.4"]}
            )

            # 寫正則表達式取出BH後面的值
            pat = "(?:Bh:?\s?)(\d{2,3}\.?\d{0,1})"

            # 利用findall來實踐
            BH = data["OBJ_DESC"].str.findall(pat, flags=re.I)
            data["new"] = BH.str[0]  # 由於上列執行完回傳值是list，先將其轉為str，再將其值取出
            print(data)
          """
          讀取row內容有三種方法
          法1. 讀取位置的，用區間的方式表示欲讀取的row的位置，
          法2. 讀取標籤的，loc，輸入欲讀取的row的標籤
          法3. 讀取位置的，iloc，同法1

          loc主要是根據index的標籤名來運作的，因此只要把標籤名改掉，loc內的值也要相對應改掉
          iloc主要是根據索引的位置來運作的，因此，即使把標籤名改掉，iloc內的值也不需要對應改掉

          如果用loc讀取僅一個row的話，顯示方式會不同，兩個以上就會是DataFrame的型式
          用loc，注意:如果沒指定index的話，那預設就是從0開始，這種情況下也能使用區間的模式，由於是用標籤來運作，所以區間的話前後是都有算的

          如果用iloc讀取僅一個row的話，顯示方式會不同，兩個以上就會是DataFrame的型式
          用iloc是取位置的，所以區間的話最後的數值都是不包含的

          讀取column內容有三種方法
          法1. 讀取欄位名，data['欄位名']
          法2. 讀取欄位名，data.'欄位名' - 此方法不建議使用，因為欄位名要是有空格就無法用了
          法3. 讀取位置，iloc[:, column的位置]，這邊是預設全部的row都要取

          iloc是取位置的，[row, column]內分兩個部分，row為row的位置，column為column的位置

          查詢資料
          用isin指令，傳回來的是布林值

          篩選資料
          利用讀取row、column、isin及運算符號來製作篩選條件，然後利用[]來篩選資料

          篩選資料搭配判別式
          由於直接用運算子做運算後的boolean的資料型態是pandas.core.series.Series的，而非一般的boolean，所以直接丟進if來使用會發生問題，因此，需搭配以下指令來進行處理
          DataFrame.bool()
          : bool是用來轉換成一般boolean用的指令，這樣就可搭配if來進行操作

          比對兩個DataFrame中重複及相異的資料
          merge: 依照指定欄位值來合併
          left_on: 左邊df要依照合併的欄位名
          right_on: 右邊df要依照合併的欄位名
          on: 兩邊都有的欄位名
          how: 決定是否完全合併，因為要是當兩個的row數不匹配時，可能結果不是想要的，將此參數給定inner的話，就會取得兩資料間的交集，也就是相同之處，而outer的話為聯集
          indicator: 是否顯示比較的結果，結果有3種
           1. left_only
           2. right_only
           3. both
          主要搭配取出相異的資料

          關於SettingWithCopyWarning
          當用Chained indexing來修改值的時候，會產生這個警告

          問題1.
          簡單的說鏈式的會一個一個獨立操作
          1.data[data["bidder"] == "davidbresler2"] # 這個會return一個新的Dataframe
          2.['bidderrate'] = 100 # 而這個賦值的操作會是作用在新的DataFrame上，而不是原本的DataFrame
          因此，會讓原有的DataFrame的值沒被修改到

          解決方法
          運用loc來將chained變成單個的操作

          問題2.
          隱藏起來的鏈式
          關於temp是用get的值創建出來的，data.loc[data.bid == data.price])可能是原始的，也可能不是
          因此，一樣有可能沒修改到原始的資料

          解決方法
          利用copy直接把值複製新的

          結論:這種給值最好就是copy搭配loc[condition]的方式，比較能確保是真實改到值

          利用正則表達式來取得資料
          findall就跟re裡面的findall差不多意思，只是Pandas裡的可以直接幫你批次處理，更是方便快速
          : pat: 正則表達式的規則
          : flags: 正則表達式的匹配模式，這邊的re.I指得是忽略大小寫
          由於findall回傳的長度會跟原data的row長度一樣，沒找到的部分會補NaN，因此，可以不用先行創建新的空白欄位          
          """          
          ```
    5. **替換資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)  # 不指定index

          # 一對一替換
          # data.replace('Amy', 'Linda', inplace=True)
          # print(data)

          # 多對一替換
          # data.replace(['Amy', 'John'], 'Linda', inplace=True)
          # print(data)

          # 多對多替換
          # data.replace({'Amy': 'Linda', 3000: 6000}, inplace=True)
          # print(data)

          # 去除空白
          # data.replace('\s+', '', regex=True, inplace=True)   # 去除空白

          # 修改欄位名
          # data = data.rename(columns={"name":"boss_name"})
          # print(data)         

          # 篩選資料後的賦值，相當於多個值替換
          # dfc = pd.DataFrame({'a': ['one', 'one', 'two',
          #                           'three', 'two', 'one', 'six'],
          #                     'c': np.arange(7),
          #                     'b': np.arange(7)})

          # dfd = dfc.copy()
          # print(dfc)
          # condition = dfd['a'].str.startswith('o')
          # dfd.loc[condition, :] = 42
          # print(dfd)
          # dfd.loc[condition, 'c'] = None
          # print(dfd)          

          """
          主要是用replace指令來替換，當中的inplace參數是指是否對原表直接做修改，預設為False
          多對多替換是用類似字典的型式

          loc[row,column]，row即是放condition返回的布林值，column即放column名稱

          注意:使用chained indexing的時候，索引操作的順序和類型部分決定了結果是原始對象的切片還是切片的副本，容易導致出來結果不如預期，因此，盡量避免

          修改欄位名
          df = df.rename(columns={"OldName":"NewName"})
          """          
          ```
    6. **新增資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)  # 不指定index

          # 新增row
          # 法1
          # data.loc[3] = ['tester', 1000000, 199]
          # data.loc[len(data)] = ['tester', 1000000, 199]
          # print(data)

          # 法2
          # data = data.append({'name': 'Linda', 'salary': 9000, 'heigh': 160}, ignore_index=True)
          # print(data)

          # 新增column
          # 法1
          # data['new'] = [100, 300, 800]
          # print(data)

          # 法2
          # data['new'] = pd.Series([100, 300])
          # print(data)

          # 插入
          # data.insert(1, 'weight', [100, 300, 800], allow_duplicates=True)
          # print(data)

          """
          新增row的兩種方法
          法1. df.loc[index名] = 值，index名可數字可文字，給予的值需符合column的長度，可搭配len來直接給予index名
          法2. 利用append，然後配合字典型式傳入想新增的資料，ignore_index是表示是否用各自原來的index label，預設為False

          新增column有兩種方法
          法1. 直接輸入欲新增的欄位名，給予的值需符合row的長度
          法2. 輸入欲新增的欄位名搭配Series給予值，給予的值不需符合row的長度，少的部分會是NaN值，注意: 如果有NaN值，那其它為數字的話，資料型態會是float64

          插入的方法基本上只有插入column的部分，使用insert指令
          df.insert(欲插入的位置, 欲插入的欄位名, 欲插入的值, allow_duplicates=True)
          給予的值需符合row的長度，allow_duplicates預設為False，此為是否允許插入同樣欄位名
          """          
          ```
    7. **刪除資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)  # 不指定index

          # data.drop(index=[1, 2], inplace=True, axis=False)
          # data.drop(columns=['name', 'salary'], inplace=True, axis=True)

          """
          基本上就是用drop指令
          : inplace是表示是否直接修改，預設為False
          : axis True為對column動作，False為對row動作，預設False
          : index是標籤名不是位置，不一定要此參數，會根據axis指定來判斷要對row還column作動
          : column是欄位名，不一定要此參數，會根據axis指定來判斷要對row還column作動
          """          
          ```
    8. **處理缺失值**
       + #### 範例
          ```python
          from numpy import NaN
          import pandas as pd

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, NaN, 230]
          }

          data = pd.DataFrame(data_dict)  # 不指定index

          # print(data.isnull())  # 查詢缺失值
          # print(data.dropna(how='all'))   # 刪除缺失值
          # print(data.fillna(0))
          # print(data.fillna({'heigh': 340}))

          """
          isnull指令為檢查缺失值
          dropna指令為刪除缺失值的row
          : how參數值'any'或'all'，當為any時，只要row中有一個NaN即整個row刪除，而all則是要全部都為NaN才刪除
          fillna指令為將所有缺失值填充為指定的值，也可利用字典的型式來給定
          """          
          ```
    9.  **處理重覆值**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [3000, 5000, 8000],
              'heigh': [180, 190, 230]
          }

          data = pd.DataFrame(data_dict)  # 不指定index
          for i in range(5):
              data.loc[len(data)] = ['Amy', 3000, 180]
              
          data.loc[len(data)] = ['Amy', 4000, 180]
          print('原本的資料\n')
          print(data, '\n')

          # print(data.duplicated()) # 找尋重複的值，回傳值是bool
          # data = data.drop_duplicates()
          # print('刪除重複值後的結果\n')
          # print(data)

          # data = data.drop_duplicates(subset=['salary']) 
          # print('僅刪除salary欄位有重複值的結果\n')
          # print(data)

          # 取得為一值
          # print('名字有以下幾個\n')
          # print(data['name'].unique())

          """
          drop_duplicates為用來刪除重複的row
          : keep參數可以有3個值，'first'、'last'、False，預設為'first'
          : 'first'參數為保留第一個重複值剩下的刪除
          : 'last'參數為保留最後一個重複值剩下的刪除
          : False值為刪除所有的重複值
          : subset參數為column labels
          unique為用來獲取欄位中唯一值
          """          
          ```
    10. **排序資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [5000, 3000, 1000],
              'heigh': [980, 130, 190]
          }

          data = pd.DataFrame(data_dict)  # 不指定index

          # print(data.sort_values(by=['salary']))  # 根據salary欄位來作排序

          # print(data.sort_values(by=['heigh'], ascending=False))  # 根據salary欄位來作排降序

          """
          sort_values為排序值用的指令，基本上就是針對欄位作為排序
          : by參數為欲排序的欄位名
          : ascending參數為指定升降序，True為升序，False為降序，預設為True
          """          
          ```
    11. **合併資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data1_dict = {
              'name': ['Amy', 'John', 'David'],
              'salary': [5000, 3000, 1000],
              'heigh': [980, 130, 190]
          }

          data2_dict = {
              'name': ['Linda', 'Emily'],
              'salary': [50000, 30000],
              'heigh': [150, 160]
          }


          data1 = pd.DataFrame(data1_dict)  # 不指定index
          data2 = pd.DataFrame(data2_dict)  # 不指定index

          # print(pd.concat([data1, data2], ignore_index=True))

          # print(data1.append(data2, ignore_index=True))
            
            # 資料根據某欄位來做合併
            A = {
                '番號': ['URKK-049', 'MKMP-430', 'MKMP-429', 'MDTM-750', 'MDTM-749', 'URKK-049'],
                '片名': ['test1', 'test2', 'test3', 'test4', 'test5', 'test']
            }

            A = pd.DataFrame(A)

            B = {
                '番號': ['URKK-049', 'MKMP-430', 'MKMP-429', 'MDTM-750', 'MDTM-749'],
                '長度': ['142分鐘', '145分鐘', '150分鐘', '120分鐘', '125分鐘']
            }

            B = pd.DataFrame(B)
            print(pd.merge(A, B, left_on='番號', right_on='番號', how='outer'))

          """
          合併有兩種方法
          法1.
          concat: 合併兩個DataFrame，axis為0(預設)是row合併，1則是column合併，注意:只能0或1不能True跟False喔，另外，如果index不同的話，column合併會是row+column合併喔
          : ignore_index參數為忽略index，預設為False，也就是預設為不忽略index，合併之後的index不會重新排列，會按照原本的
          : axis，如果為0則為row合併，1為column合併，預設為0
          法2.
          append: 用法跟新增row一樣

          根據欄位值合併
          merge: 依照指定欄位值來合併
          left_on: 左邊df要依照合併的欄位名
          right_on: 右邊df要依照合併的欄位名
          how: 決定是否完全合併，因為要是當兩個的row數不匹配時，可能結果不是想要的，將此參數給定outer的話，那缺失值會直接補NaN
          """          
          ```
    12. **對齊資料**
       + #### 範例
          ```python
          import pandas as pd

          # 創建資料
          data = {
              '收據編號': ['P02124179', 'P02124179', 'P02124183', 'P02124180', 'P02124087', 'P02125499', 'P02125307', 'P02125307', 'P02125256', 'P02125256', 'P02125259', 'P02125259'],
              '付款項目': ['規費', '服務費', '服務費', '服務費', '服務費', '服務費', '服務費', '規費', '服務費', '規費', '服務費', '規費'],
              '傳票號碼': ['J21100730045', 'J21100730046', 'J21100730046', 'J21100730047', 'J21100730048', 'F21100830001', 'F21100923001', 'F21100907009', 'F21101021001', 'F21101021002', 'F21101021003', 'F21101021004'],
              '預計付款日': ['2021/11/05', '2021/11/05', '2021/11/05', '2021/11/05', '2021/11/05', '2021/11/05', '2021/12/05', '2021/12/05', '2021/12/05', '2021/12/05', '2021/12/05', '2021/12/05'],
              '付款金額': [455, 1850, 700, 630, 700, 6000, 1000, 3341, 800, 350, 3150, 3787]
          }

          data = pd.DataFrame(data)
          pd.set_option('display.unicode.ambiguous_as_wide', True)    # 顯示對齊用
          pd.set_option('display.unicode.east_asian_width', True)     # 顯示對齊用
          print(data)          
          ```
    13. **其餘常用功能**
      + #### 範例
        ```python
        import pandas as pd

        # 創建資料
        data_dict = {
            'name': ['Amy', 'John', 'David'],
            'salary': [5000, 3000, 1000],
            'heigh': [980, 130, 190]
        }

        data = pd.DataFrame(data_dict)

        # print("薪水平均值:", data['salary'].mean())
        # print("薪水總和:", data['salary'].sum())
        # print("DataFrame的尺寸", data.shape)
        # print('欄位名:', data.columns)
        # print("統計出現次數:", data_dict['salary'].value_counts())
        # print(pd.isna(data_dict['name'][0]))
        # print(data['salary'].to_numpy())

        """
        mean: 欄位的平均值
        sum: 欄位的總和值
        shape: DataFrame的尺寸，m(row) * n(column)
        column: 欄位的名稱
        value_counts: 統計值所出現的次數
        isna: 查看值是否為NaN
        to_numpy: 把欄位值變成numpy的格式
        注意: value_counts基本上是針對Series的部分，所以即使把整個DataFrame丟進去也會是每個Column各自做統計，因此，想要統計整個DataFrame的話，可以先把DataFrame給變成一個Series，然後再做統計的動作
        """        
        ```
    14. **深入merge**
      + #### 範例
        ```python
        import pandas as pd
        left = pd.DataFrame({
            'key': ['K0', 'K1', 'K2', 'K3'],
            'A': ['A0', 'A1', 'A2', 'A3'],
            'B': ['B0', 'B1', 'B2', 'B3']
        })
        right = pd.DataFrame({
            'key': ['K0', 'K1', 'K2', 'K3'],
            'C': ['C0', 'C1', 'C2', 'C3'],
            'D': ['D0', 'D1', 'D2', 'D3']
        })



        # 例1.最簡單的合併
        # print(left)
        # print(right)
        # result = pd.merge(left, right)
        # print(result)

        # 例2.多個column name重複的問題
        # right = right.drop(columns=['C'], axis=1)
        # right['A'] = ['A4', 'A1', 'A2', 'A4']
        # print(left)
        # print(right)
        # result = pd.merge(left, right)
        # print(result)

        # 例3.聯集
        # right = right.drop(columns=['C'], axis=1)
        # right['A'] = ['A4', 'A1', 'A2', 'A4']
        # print(left)
        # print(right)
        # result = pd.merge(left, right, on='key')
        # print(result)

        # 例4.左右長度不一做交集
        # right.drop(index=[1, 2], inplace=True, axis=False)
        # print(left)
        # print(right)
        # result = pd.merge(left, right)
        # print(result)

        # 例5.左右長度不一做交集(以較多row的那邊為主)
        # right.drop(index=[1, 2], inplace=True, axis=False)
        # print(left)
        # print(right)
        # result = pd.merge(left, right, how='left')
        # print(result)

        # 例6.左右長度不一做聯集
        # right.drop(index=[1, 2], inplace=True, axis=False)
        # print(left)
        # print(right)
        # result = pd.merge(left, right, how='outer')
        # print(result)

        # 例7.左右長度不一做聯集(以較少row的那邊為主)
        # right.drop(index=[1, 2], inplace=True, axis=False)
        # print(left)
        # print(right)
        # result = pd.merge(left, right, how='right')
        # print(result)

        # 例8.兩邊不同欄位名作交集
        # left = left.rename(columns={'key': 'key_left'})
        # right = right.rename(columns={'key': 'key_right'})
        # print(left)
        # print(right)
        # result = pd.merge(left, right, left_on='key_left', right_on='key_right')
        # print(result)

        # 例9.左邊的值有重複項做交集
        # left['key'].loc[1] = 'K0'
        # left['key'].loc[2] = 'K0'
        # print(left)
        # print(right)
        # result = pd.merge(left, right)
        # print(result)

        # 例10.左邊的值有重複項做聯集
        # left['key'].loc[1] = 'K0'
        # left['key'].loc[2] = 'K0'
        # print(left)
        # print(right)
        # result = pd.merge(left, right, how='outer')
        # print(result)

        # # 例11.兩邊都有重複的值做交集
        # left['key'].loc[1] = 'K0'
        # left['key'].loc[2] = 'K0'
        # right['key'].loc[1] = 'K0'
        # right['key'].loc[2] = 'K5'
        # print(left)
        # print(right)
        # result = pd.merge(left, right)
        # print(result)

        # 例12.兩邊都有重複的值做交集(右邊為主)
        # left['key'].loc[1] = 'K0'
        # left['key'].loc[2] = 'K0'
        # right['key'].loc[1] = 'K0'
        # right['key'].loc[2] = 'K5'
        # print(left)
        # print(right)
        # result = pd.merge(left, right, how='right')
        # print(result)

        """
        結論:使用merge時，要先觀察兩邊的檔案是否有重複性
        例1中可以看出，它會尋找共同的column name中相同值的row做合併，若兩邊相同的column name不只一個，那表示複數的column name都要有相同的值才會取出，如例2
        例3中可看出，左右都有相同的column name做聯集時，縱使有不同的值，還是可以合併，就是會多column另外命名處理
        例5中可看出，左邊的row比右邊多，做交集的話，設定以左邊為主，那缺失的部分會自動補NaN
        例6中可看出，左邊的row比右邊多，做聯集的話，會以最多row的為主，然後缺失部分會自動補NaN
        例7中可看出，以較少row的那邊為主的話，row數量就會是跟該側一樣
        例11中可看出，雙邊重複的話，資料量一定會暴增
        例12中可看出，雙邊重複的話，如果以左邊為主的話效果會跟例11相同，如果改以右邊為主，那right_only的部分則會補NaN值
        :param how: str，default=inner，決定要inner交集、outer聯集、left左邊為主、right右邊為主 
        :param indicator: bool，default=False，是否顯示merge的方法，基本上只有三種，both、left_only、right_only
        :param on: IndexLabel，欲根據兩邊都有的column name
        :param left_on: IndexLabel，欲根據左邊的column name
        :param right_on: IndexLabel，欲根據右邊的column name
        """        
        ```

    15. **將整個Df內所有元素滿足條件的整row變特定值**
      + #### 範例
        ```python
        import pandas as pd

        # 計數整個DataFrame所有元素出現的次數
        # left = pd.DataFrame({
        #     'key': ['K0', 'K1', 'B2', 'K3'],
        #     'A': ['A1', 'A1', 'A2', 'A1'],
        #     'B': ['B0', 'A1', 'B2', 'B3']
        # })

        # result = left.stack().value_counts()    # 計數整個DataFrame所有元素出現的次數
        # print(result)        

        """
        stack(): 將資料的列“旋轉”為行
        value_counts(): 計數次數
        """

        # 將index轉成column
        # left = pd.DataFrame({
        #     'key': ['K0', 'K1', 'B2', 'K3'],
        #     'A': ['A1', 'A1', 'A2', 'A1'],
        #     'B': ['B0', 'A1', 'B2', 'B3']
        # })

        # result = left.stack().value_counts()    # 計數整個DataFrame所有元素出現的次數
        # df = result.rename_axis('name').reset_index()   # 將index轉成column
        # print(df)   

        """
        rename_axis: 設置索引或列的軸名稱
        reset_index(): 重置index
        """

        # 從整個Df中找出特定值
        # left = pd.DataFrame({
        #     'key': ['K0', 'K1', 'B2', 'K3'],
        #     'A': ['A1', 'A1', 'A2', 'A0'],
        #     'B': ['B0', 'A1', 'B2', 'B3']
        # })

        # print(left)
        # print('分隔線')
        # print(left[left.isin(['B2', 'A1']).any(axis=1)])    # 找出DataFrame所有元素中，包含A1或B2的元素 

        # 將Df中，僅出現一次的元素，整row變為0
        # left = pd.DataFrame({
        #     'key': ['A1', 'K1', 'B2', 'K3'],
        #     'A': ['A1', 'A1', 'A2', 'A0'],
        #     'B': ['A1', 'A1', 'B2', 'B3']
        # })

        # result = left.stack().value_counts()    # 計數整個DataFrame所有元素出現的次數
        # df = result.rename_axis('name').reset_index()   # 將index轉成column
        # df = df.rename(columns={0: 'count'})    # 將column name修改一下
        # condition1 = df['count'] < 2 # 條件設定
        # condition2 = left.isin(list(df[condition1].name)).any(axis=1)    # 找出DataFrame所有元素中，包含condition內的元素   
        # left_new = left.copy()  # 複製以便比較
        # left_new[condition2] = left_new[condition2].replace(list(df.name), '0') # 從原Df找出符合條件的值，將其值變為'0'
        # print(df)
        # print('分隔線')
        # print(left)
        # print('分隔線')
        # print(left_new)
        ```
        




+ ## 參考資料
  [參考網站](https://www.delftstack.com/zh-tw/howto/python-pandas/)
  [參考網站](https://pandas.pydata.org/docs/user_guide/index.html)
  [參考網站](https://iter01.com/585529.html)